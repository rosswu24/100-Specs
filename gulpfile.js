(function () { "use strict";
var $estr = function() { return js.Boot.__string_rec(this,''); };
var HxOverrides = function() { }
HxOverrides.cca = function(s,index) {
    var x = s.charCodeAt(index);
    if(x != x) return undefined;
    return x;
}
HxOverrides.substr = function(s,pos,len) {
    if(pos != null && pos != 0 && len != null && len < 0) return "";
    if(len == null) len = s.length;
    if(pos < 0) {
        pos = s.length + pos;
        if(pos < 0) pos = 0;
    } else if(len < 0) len = s.length + len - pos;
    return s.substr(pos,len);
}
var Std = function() { }
Std.parseInt = function(x) {
    var v = parseInt(x,10);
    if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) v = parseInt(x);
    if(isNaN(v)) return null;
    return v;
}
var js = {}
js.Node = function() { }
js.Node.get_assert = function() {
    return js.Node.require("assert");
}
js.Node.get_child_process = function() {
    return js.Node.require("child_process");
}
js.Node.get_cluster = function() {
    return js.Node.require("cluster");
}
js.Node.get_crypto = function() {
    return js.Node.require("crypto");
}
js.Node.get_dgram = function() {
    return js.Node.require("dgram");
}
js.Node.get_dns = function() {
    return js.Node.require("dns");
}
js.Node.get_fs = function() {
    return js.Node.require("fs");
}
js.Node.get_http = function() {
    return js.Node.require("http");
}
js.Node.get_https = function() {
    return js.Node.require("https");
}
js.Node.get_net = function() {
    return js.Node.require("net");
}
js.Node.get_os = function() {
    return js.Node.require("os");
}
js.Node.get_path = function() {
    return js.Node.require("path");
}
js.Node.get_querystring = function() {
    return js.Node.require("querystring");
}
js.Node.get_repl = function() {
    return js.Node.require("repl");
}
js.Node.get_tls = function() {
    return js.Node.require("tls");
}
js.Node.get_url = function() {
    return js.Node.require("url");
}
js.Node.get_util = function() {
    return js.Node.require("util");
}
js.Node.get_vm = function() {
    return js.Node.require("vm");
}
js.Node.get_zlib = function() {
    return js.Node.require("zlib");
}
js.Node.get___filename = function() {
    return __filename;
}
js.Node.get___dirname = function() {
    return __dirname;
}
js.Node.get_json = function() {
    return JSON;
}
js.Node.newSocket = function(options) {
    return new js.Node.net.Socket(options);
}
var Gulpfile = function() { }
Gulpfile.main = function() {
    Gulpfile.gulp.task("default",["connect","watch"]);
    Gulpfile.gulp.task("watch",Gulpfile.watch_task);
    Gulpfile.gulp.task("connect",Gulpfile.connect_task);
}
Gulpfile.connect_task = function(cb) {
    Gulpfile.connect.server({ root : "./public", host : "localhost", port : 3333, livereload : true});
    js.Node.require("child_process").exec("open http://" + "localhost" + ":" + 3333 + " && subl " + "./public" + "/js/class-definitions.js",null,function(error,stdout,stderr) {
        console.log("          «--´¯`--–…·´--».-.- ( NOTICE ) -.-.«-`·…–--´¯`-----»\n\n          You need to have the LiveReload chrome extension installed\n          get it here:\n          ╔══════════════════════════════════════╗\n            http://tinyurl.com/chrome-livereload\n          ╚══════════════════════════════════════╝\n          \n          Make sure this script tag is included in your html\n            - else manually start livereload chrome extension\n\n          ╔════════════════════════════════════════════════════════════════════════╗\n            <script src=\"http://localhost:35729/livereload.js?snipver=1\"></script>\n          ╚════════════════════════════════════════════════════════════════════════╝\n\n          (¯`·._.·[ Opened " + "./public" + "/index.html in your default web browser ]·._.·´¯)\n\n          •^v^–[ Opened " + "./public" + "/js/class-definitions.js in Sublime Text ]–^v^•\n          ");
    });
}
Gulpfile.watch_task = function(cb) {
    Gulpfile.gulp.watch(["" + "./public" + "/**"],Gulpfile.reload);
}
Gulpfile.reload = function(event) {
    Gulpfile.gulp.src("" + "./public" + "/**").pipe(Gulpfile.connect.reload());
}
var StringBuf = function() {
    this.b = "";
};
var haxe = {}
haxe.io = {}
haxe.io.Bytes = function(length,b) {
    this.length = length;
    this.b = b;
};
haxe.io.Bytes.alloc = function(length) {
    return new haxe.io.Bytes(length,new Buffer(length));
}
haxe.io.Bytes.ofString = function(s) {
    var nb = new Buffer(s,"utf8");
    return new haxe.io.Bytes(nb.length,nb);
}
haxe.io.Bytes.ofData = function(b) {
    return new haxe.io.Bytes(b.length,b);
}
haxe.io.Bytes.prototype = {
    getData: function() {
        return this.b;
    }
    ,toHex: function() {
        var s = new StringBuf();
        var chars = [];
        var str = "0123456789abcdef";
        var _g1 = 0, _g = str.length;
        while(_g1 < _g) {
            var i = _g1++;
            chars.push(HxOverrides.cca(str,i));
        }
        var _g1 = 0, _g = this.length;
        while(_g1 < _g) {
            var i = _g1++;
            var c = this.b[i];
            s.b += String.fromCharCode(chars[c >> 4]);
            s.b += String.fromCharCode(chars[c & 15]);
        }
        return s.b;
    }
    ,toString: function() {
        return this.readString(0,this.length);
    }
    ,readString: function(pos,len) {
        if(pos < 0 || len < 0 || pos + len > this.length) throw haxe.io.Error.OutsideBounds;
        var s = "";
        var b = this.b;
        var fcc = String.fromCharCode;
        var i = pos;
        var max = pos + len;
        while(i < max) {
            var c = b[i++];
            if(c < 128) {
                if(c == 0) break;
                s += fcc(c);
            } else if(c < 224) s += fcc((c & 63) << 6 | b[i++] & 127); else if(c < 240) {
                var c2 = b[i++];
                s += fcc((c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127);
            } else {
                var c2 = b[i++];
                var c3 = b[i++];
                s += fcc((c & 15) << 18 | (c2 & 127) << 12 | c3 << 6 & 127 | b[i++] & 127);
            }
        }
        return s;
    }
    ,compare: function(other) {
        var b1 = this.b;
        var b2 = other.b;
        var len = this.length < other.length?this.length:other.length;
        var _g = 0;
        while(_g < len) {
            var i = _g++;
            if(b1[i] != b2[i]) return b1[i] - b2[i];
        }
        return this.length - other.length;
    }
    ,sub: function(pos,len) {
        if(pos < 0 || len < 0 || pos + len > this.length) throw haxe.io.Error.OutsideBounds;
        var nb = new Buffer(len), slice = this.b.slice(pos,pos + len);
        slice.copy(nb,0,0,len);
        return new haxe.io.Bytes(len,nb);
    }
    ,blit: function(pos,src,srcpos,len) {
        if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) throw haxe.io.Error.OutsideBounds;
        src.b.copy(this.b,pos,srcpos,srcpos + len);
    }
    ,set: function(pos,v) {
        this.b[pos] = v;
    }
    ,get: function(pos) {
        return this.b[pos];
    }
}
haxe.io.Error = { __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"] }
haxe.io.Error.Blocked = ["Blocked",0];
haxe.io.Error.Blocked.toString = $estr;
haxe.io.Error.Blocked.__enum__ = haxe.io.Error;
haxe.io.Error.Overflow = ["Overflow",1];
haxe.io.Error.Overflow.toString = $estr;
haxe.io.Error.Overflow.__enum__ = haxe.io.Error;
haxe.io.Error.OutsideBounds = ["OutsideBounds",2];
haxe.io.Error.OutsideBounds.toString = $estr;
haxe.io.Error.OutsideBounds.__enum__ = haxe.io.Error;
haxe.io.Error.Custom = function(e) { var $x = ["Custom",3,e]; $x.__enum__ = haxe.io.Error; $x.toString = $estr; return $x; }
js.NodeC = function() { }
js.Node.setTimeout = setTimeout;
js.Node.clearTimeout = clearTimeout;
js.Node.setInterval = setInterval;
js.Node.clearInterval = clearInterval;
js.Node.global = global;
js.Node.process = process;
js.Node.require = require;
js.Node.console = console;
js.Node.module = module;
js.Node.stringify = JSON.stringify;
js.Node.parse = JSON.parse;
var version = HxOverrides.substr(js.Node.process.version,1,null).split(".").map(Std.parseInt);
if(version[0] > 0 || version[1] >= 9) {
    js.Node.setImmediate = setImmediate;
    js.Node.clearImmediate = clearImmediate;
}
Gulpfile.WEBROOT = "./public";
Gulpfile.HOST = "localhost";
Gulpfile.PORT = 3333;
Gulpfile.AUTO_OPEN_BROWSER = true;
Gulpfile.gulp = js.Node.require("gulp");
Gulpfile.connect = js.Node.require("gulp-connect");
js.NodeC.UTF8 = "utf8";
js.NodeC.ASCII = "ascii";
js.NodeC.BINARY = "binary";
js.NodeC.BASE64 = "base64";
js.NodeC.HEX = "hex";
js.NodeC.EVENT_EVENTEMITTER_NEWLISTENER = "newListener";
js.NodeC.EVENT_EVENTEMITTER_ERROR = "error";
js.NodeC.EVENT_STREAM_DATA = "data";
js.NodeC.EVENT_STREAM_END = "end";
js.NodeC.EVENT_STREAM_ERROR = "error";
js.NodeC.EVENT_STREAM_CLOSE = "close";
js.NodeC.EVENT_STREAM_DRAIN = "drain";
js.NodeC.EVENT_STREAM_CONNECT = "connect";
js.NodeC.EVENT_STREAM_SECURE = "secure";
js.NodeC.EVENT_STREAM_TIMEOUT = "timeout";
js.NodeC.EVENT_STREAM_PIPE = "pipe";
js.NodeC.EVENT_PROCESS_EXIT = "exit";
js.NodeC.EVENT_PROCESS_UNCAUGHTEXCEPTION = "uncaughtException";
js.NodeC.EVENT_PROCESS_SIGINT = "SIGINT";
js.NodeC.EVENT_PROCESS_SIGUSR1 = "SIGUSR1";
js.NodeC.EVENT_CHILDPROCESS_EXIT = "exit";
js.NodeC.EVENT_HTTPSERVER_REQUEST = "request";
js.NodeC.EVENT_HTTPSERVER_CONNECTION = "connection";
js.NodeC.EVENT_HTTPSERVER_CLOSE = "close";
js.NodeC.EVENT_HTTPSERVER_UPGRADE = "upgrade";
js.NodeC.EVENT_HTTPSERVER_CLIENTERROR = "clientError";
js.NodeC.EVENT_HTTPSERVERREQUEST_DATA = "data";
js.NodeC.EVENT_HTTPSERVERREQUEST_END = "end";
js.NodeC.EVENT_CLIENTREQUEST_RESPONSE = "response";
js.NodeC.EVENT_CLIENTRESPONSE_DATA = "data";
js.NodeC.EVENT_CLIENTRESPONSE_END = "end";
js.NodeC.EVENT_NETSERVER_CONNECTION = "connection";
js.NodeC.EVENT_NETSERVER_CLOSE = "close";
js.NodeC.FILE_READ = "r";
js.NodeC.FILE_READ_APPEND = "r+";
js.NodeC.FILE_WRITE = "w";
js.NodeC.FILE_WRITE_APPEND = "a+";
js.NodeC.FILE_READWRITE = "a";
js.NodeC.FILE_READWRITE_APPEND = "a+";
Gulpfile.main();
})();
